# Import required modules
from dataclasses import dataclass, field
from numpy.random import choice
from typing import List, Union
from sys import getsizeof
import PIL

# Custom modules
from .augOperator import AugOperator
from .color import Color
from .augUtils import UtilClass

class AugSeq:
    """
    @attr
        _augList: private data member. Dictionary to store all the AugOperators
        _choice_name: private data member. Holds the name of randomly choosen
                    Augmentation Operator
        _AugObjList: this list initially holds all the Augmentation Operators
                    in a list
    """

    def __init__(self):
        """
        @desc
        >>> Initiates after init method automatically
        """
        self.__AugObjList: List = []
        self.__augList: dict = {}
        self.__ran_gen_list: list = []
        self.__util: UtilClass = UtilClass()
        self.__update: bool = True
    
    def __repr__(self):
        return self.__class__.__name__
    
    def add(self, obj: AugOperator)->None:
        """
        @desc
        >>> add the Augmentation Operator object to Augmentation Pool

        @example
        >>> INPUT
        >>> trialOpr = AugOperator(...)
        >>> Augs.add(trialOpr)
        >>> Augs.show()
        >>> 
        >>> OUTPUT
        {
        ... ,
        'trial': Augmentation Operator() .. ,
        }
        """
        self.__augList.update({obj.name:obj})
    
    def add_augObj_List(self, augObj: List[AugOperator])->None:
        """
        @desc
        >>> adds the Augmentation Operator Objects to a list.
        """
        self.__AugObjList = augObj
    
    def apply_random(self, data: List[PIL.Image.Image], current_epoch:int=1, update:bool = True)->None:
        """
        @desc
        >>> apply randomly chosen augmentation operator over the image/batch of images

        @example
        >>> for epoch in range(epochs+1):
        >>>     for data,_ in dataloader:
        >>>         x_aug, x = Augs.apply_random(data, epoch), data
        """
        self.__update = update
        return self.__apply_random(data, current_epoch, update)

    def choose_random(self, current_epoch:int=1)->None:
        """
        @desc
        >>> chooses a random Augmentation Operator from Augmentation Operator Pool
        which have highest probabilities or from the list generated by
        self._maxProb()

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.chooseRandom()
        >>> 
        >>> OUTPUT
        'blur'
        """
        if len(self.__ran_gen_list)>0:
            self.__ran_gen_list.clear()
        eta = ((current_epoch-1)*self.__util.l)//self.__util.te + 1
        for _ in range(eta):
            max_prob_names = self.__max_prob()
            name = choice(max_prob_names)
            self.operator(name).update_probability()
            self.__ran_gen_list.append(name)
    
    def frequency(self)->dict:
        """
        @desc
        gives a dictionary of all the frequency of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init()
        >>> Augs.frequency()
        >>> 
        >>> OUTPUT
        {
            'AugOprName' : <int>frequency,
            ...,
        }
        """
        new_dict = {}
        for key, value in self.__augList.items():
            new_dict.update({key: 1//value.probability})
        return new_dict
    
    def get_parameters_value(self)->dict:
        params = {}
        for name, augopr in self.__augList.items():
            params.update({name:augopr.get_parameters(self.__update)})
        return params

    def init(self, dataset_size:int, total_epochs:int, batch_size:int, lamda:int)->str:
        """
        @desc
        add all the objects to _augList

        @example
        >>> Augs.show()
        {}
        >>> Augs.init(...)
        >>> Augs.show()
        { key:value ...}
        """
        self.__util.dataset_size(dataset_size).batch_size(batch_size).total_epochs(total_epochs).lamda(lamda)
        self.__add_objects(self.__AugObjList)
        self.__util.omega(self.length())
        return self.__init_summary(self.__util)
        
    def length(self)->int:
        return len(self.__augList)

    def operator(self, string:str)->AugOperator:
        """
        @desc
        functional form of indexing a list

        @example
        >>> INPUT
        >>> from ProAugs.augs import Augs
        >>> Augs.init()
        >>> Blur = Augs.operator('blur')
        >>> Blur.probability()
        >>> 
        >>> OUTPUT
        1.0
        """
        return self.__augList[string]
    
    def probability(self)->dict:
        """
        @desc
        gives a dictionary of all the probabilities of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.probability()
        >>> 
        >>> OUTPUT
        {
            "AugOprName" : <float>probability,
            ...,
        }
        """
        new_dict = {}
        for key, value in self.__augList.items():
            new_dict.update({key: value.probability})
        return new_dict

    def reset(self, current_epoch: int=1)->None:
        """
        
        """
        self.__reset_probability(current_epoch)

    def show(self)->Union[dict,str]:
        """
        @desc
            return the _augList dictionary
        """
        return self.__augList
    
    def size(self)->str:
        """
        @desc
            returns the size of whole _augList dictionary in bytes, and string
            format.

        @example
            >>> INPUT 
            >>> Augs.size()
            >>> 
            >>> OUTPUT
            345 bytes
        """
        return self._string_size()
    
    def summary(self)->str:
        """
        @desc 
            gives the summary of Augmentation Pool
        """
        return self.__init_summary(self.util) + "\n" + self.show()
    
    def update_parameters(self, current_epoch:int=1)->None:

        for aug_name in self.__ran_gen_list:
            self.operator(aug_name).update_parameters(self.__util, current_epoch)
    
    def update_probability(self)->None:
        """
        @desc
            updates the probability of the randomly choosen Augmentation Operator.
            It works in conjunction with chooseRandom(). attribute _choice_name is
            assigned the chooseRandom() value, which is now publicily accessible in
            the dataclass.

        @example
        >>> INPUT
        >>> Augs.choose_random()
        >>> Augs.update_probability()
        """
        for aug in self.__ran_gen_list:
            self.__augList[aug].update_probability()
    
    def __add_objects(self, objs:List[AugOperator])->dict:
        """
        @desc
        >>> adds the list of Augmentation Operator objects to _augList dictionary.
        If objs doesn't exist then objs would be added to _augList.
        """
        for obj in objs:
            self.__augList.update({obj.name:obj})
        return self.__augList
    
    def __apply_random(self, data:PIL.Image.Image=1, current_epoch:int=1, update:bool=True)->None:

        self.choose_random(current_epoch)
        if update:
            self.update_parameters(current_epoch)
        self.reset(current_epoch)
    
    def __compose(self):
        pass

    def __init_summary(self, utils: UtilClass)->str:

        var = """{green}Augs initiated with\n  DATASET_SIZE: {magenta}{ds}{green},\n  TOTAL_EPOCHS: {magenta}{te}{green},\n  BATCH_SIZE: {magenta}{bs}{green},\n  LAMDA: {magenta}{la}{green},\n  OMEGA: {magenta}{om}{reset}"""
        return var.format(
                green=Color.GREEN, magenta=Color.MAGENTA,
                reset=Color.RESET, te=utils.te,
                bs=utils.bs, la=utils.l, om=utils.o, ds=utils.ds
            )
    
    def __reset_probability(self, current_epoch: int=1)->None:
        if self.__util.isChange(current_epoch):
            for _, value in self.__augList.items():
                value.probability = 1.0

    # def __reset_parameters(self, util: UtilClass=self.__util, current_epoch: int=1)->None:
    #     for name, augopr in self.__augList.items():
    #         augopr.__reset_parameters(util, current_epoch)

    def __string_size(self)->str:
        """
        @desc
        >>> get the size of whole _augList dictionary in bytes
        """
        size = str(getsizeof(self._augList)) + " bytes"
        return size

    def __max_prob(self)->List[str]:
        """
        @desc
        >>> find the list of names of those Augmentation Operator Objects which have
        highest probability
        """
        max_value = max([value.probability for _, value in self.__augList.items()])
        max_aug_names = [key for key,value in self.__augList.items() if value.probability==max_value]
        return max_aug_names