# Import required modules
from dataclasses import dataclass, field
from numpy.random import choice
from typing import List, Union
from sys import getsizeof
import PIL

# Custom modules
from .augOperator import AugOperator
from .color import Color
from .augUtils import UtilClass
from ProAug import utils

@dataclass
class AugSeq:
    """
    @attr
        _augList: private data member. Dictionary to store all the AugOperators
        _choice_name: private data member. Holds the name of randomly choosen
                    Augmentation Operator
        _AugObjList: this list initially holds all the Augmentation Operators
                    in a list
    """

    def __post_init__(self):
        """
        @desc
        Initiates after init method automatically
        """
        self._AugObjList:List = []
        self._augList:dict = {}
        self._ran_gen_list:list = []
        self._choiceName:str=field(default='blur')
        self._meta_dict:dict = {}
        self.util:UtilClass = UtilClass()
    
    def __repr__(self):
        return self.__class__.__name__
    
    def add(self, obj:AugOperator)->None:
        """
        @desc
        add the Augmentation Operator object to Augmentation Pool

        @example
        >>> INPUT
        >>> trialOpr = AugOperator(...)
        >>> Augs.add(trialOpr)
        >>> Augs.show()
        >>> 
        >>> OUTPUT
        {
        ... ,
        'trial': Augmentation Operator() .. ,
        }
        """
        self._augList.update({obj.name:obj})
        return self._augList
    
    def add_objects(self, objs:List[AugOperator])->dict:
        """
        @desc
        adds the list of Augmentation Operator objects to _augList dictionary.
        If objs doesn't exist then objs would be added to _augList.
        """
        for obj in objs:
            self._augList.update({obj.name:obj})
        return self._augList
    
    def add_augObj_List(self, augObj:List)->None:
        """
        @desc
        adds the Augmentation Operator Objects to a list.
        """
        self._AugObjList = augObj
    
    def apply_random(self, data:List[PIL.Image.Image]=1, current_epoch:int=1)->None:
        """
        @desc
            apply randomly chosen augmentation operator over the image/batch of images

        @example
            >>> for epoch in range(epochs+1):
            >>>     for data,_ in dataloader:
            >>>         x_aug, x = Augs.apply_random(data, epoch), data
        """
        return self._apply_augs(data, current_epoch)

    def choose_random(self, current_epoch:int=1)->List[str]:
        """
        @desc
        chooses a random Augmentation Operator from Augmentation Operator Pool
        which have highest probabilities or from the list generated by
        self._maxProb()

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.chooseRandom()
        >>> 
        >>> OUTPUT
        'blur'
        """
        eta = ((current_epoch-1)*self.utils.l)//self.utils.te + 1
        for _ in range(eta):
            max_prob_names = self._max_prob()
            self._ran_gen_list.append(choice(max_prob_names))
        return self._ran_gen_list
    
    def frequency(self)->dict:
        """
        @desc
        gives a dictionary of all the frequency of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init()
        >>> Augs.frequency()
        >>> 
        >>> OUTPUT
        {
            'AugOprName' : <int>frequency,
            ...,
        }
        """
        new_dict = {}
        for key, value in self._augList.items():
            new_dict.update({key: 1//value.probability})
        return new_dict
    
    def init(self, dataset_size:int, total_epochs:int, batch_size:int, lamda:int)->str:
        """
        @desc
        add all the objects to _augList

        @example
        >>> Augs.show()
        {}
        >>> Augs.init(...)
        >>> Augs.show()
        { key:value ...}
        """
        self.util.dataset_size(dataset_size).batch_size(batch_size).total_epochs(total_epochs).lamda(lamda)
        self.add_objects(self._AugObjList)
        self.util.omega(self.length())
        var = """{green}Augs initiated with\n  DATASET_SIZE: {magenta}{ds}{green},\n  TOTAL_EPOCHS: {magenta}{te}{green},\n  BATCH_SIZE: {magenta}{bs}{green},\n  LAMDA: {magenta}{la}{green},\n  OMEGA: {magenta}{om}{reset}"""
        return var.format(
                green=Color.GREEN, magenta=Color.MAGENTA,
                reset=Color.RESET, te=utils.te,
                bs=utils.bs, la=utils.l, om=utils.o, ds=utils.ds
            )
        
    def length(self)->int:
        return len(self._augList)

    def operator(self, string:str)->AugOperator:
        """
        @desc
        functional form of indexing a list

        @example
        >>> INPUT
        >>> from ProAugs.augs import Augs
        >>> Augs.init()
        >>> Blur = Augs.operator('blur')
        >>> Blur.probability()
        >>> 
        >>> OUTPUT
        1.0
        """
        return self._augList[string]
    
    def probability(self)->dict:
        """
        @desc
        gives a dictionary of all the probabilities of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.probability()
        >>> 
        >>> OUTPUT
        {
            "AugOprName" : <float>probability,
            ...,
        }
        """
        new_dict = {}
        for key, value in self._augList.items():
            new_dict.update({key: value.probability})
        return new_dict

    def reset(self, this:str)->None:
        """
        @desc
        reset the values

        @example
        >>> INPUT
        >>> Augs.reset("probabilities")
        >>> Augs.probabilities()
        >>> 
        >>> OUTPUT
        <all probabilities would be reseted to 1.0>
        """
        if this == "probabilities":
            for _, values in self._augList.items():
                values.probability = 1.0

    def show(self)->Union[dict,str]:
        """
        @desc
        return the _augList dictionary
        """
        return self._augList
    
    def size(self)->str:
        """
        @desc
        returns the size of whole _augList dictionary in bytes, and string
        format.

        @example
        >>> INPUT 
        >>> Augs.size()
        >>> 
        >>> OUTPUT
        345 bytes
        """
        return self._string_size()
    
    def update_parameters(self, rand_gen_list:List[str], utils:UtilClass=self.util,current_epoch:int=1)->None:

        for aug_name in rand_gen_list:
            self.operator(aug_name).update_parameters(self.util, current_epoch)
    
    def update_probability(self)->None:
        """
        @desc
            updates the probability of the randomly choosen Augmentation Operator.
            It works in conjunction with chooseRandom(). attribute _choice_name is
            assigned the chooseRandom() value, which is now publicily accessible in
            the dataclass.

        @example
        >>> INPUT
        >>> Augs.choose_random()
        >>> Augs.update_probability()
        """
        for aug in self._ran_gen_list:
            self._augList[aug].update_probability()
    
    def _apply_augs(self, data:PIL.Image.Image=1, current_epoch:int=1)->None:

        self._rand_gen_list = self.choose_random(current_epoch)
        self.update_parameters(self._ran_gen_list, self.util, current_epoch)
        self._compose()
    
    def _compose(self):
        pass
    
    def _string_size(self)->str:
        """
        @desc
        get the size of whole _augList dictionary in bytes
        """
        size = str(getsizeof(self._augList)) + " bytes"
        return size

    def _max_prob(self)->List[str]:
        """
        @desc
        find the list of names of those Augmentation Operator Objects which have
        highest probability
        """
        max_value = max([value.probability for key, value in self._augList.items()])
        max_aug_names = [key for key,value in self._augList.items() if value.probability==max_value]
        return max_aug_names