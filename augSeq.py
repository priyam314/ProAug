# Import required modules
from dataclasses import dataclass, field
from numpy.random import choice
from typing import List, Union
from sys import getsizeof
import PIL
from multiprocessing import Pool
from functools import partial
from pprint import pformat

# Custom modules
from .augOperator import AugOperator
from .color import Color
from .augUtils import UtilClass

class AugSeq:
    """
    @attr
    >>> __augList: private data member. Dictionary to store all the AugOperators
    >>> __AugObjList: this list initially holds all the Augmentation Operators in a list
    """
    ### Dunder Methods ###

    def __init__(self):
        """
        @desc
        >>> Initiates after init method automatically
        """
        self.__AugObjList: List = []
        self.__augList: dict = {}
        self.__ran_gen_list: list = []
        self.util: UtilClass = UtilClass()
        self.__update: bool = True
        self.__current_count: int = 0

    def __repr__(self):
        return self.__class__.__name__
    
    ### Insert ###

    def add(self, 
        obj: AugOperator
        )->None:
        """
        @desc
        >>> add the Augmentation Operator object to Augmentation Pool

        @example
        >>> INPUT
        >>> trialOpr = AugOperator(...)
        >>> Augs.add(trialOpr)
        >>> Augs.show()
        >>> 
        >>> OUTPUT
        {
        ... ,
        'trial': Augmentation Operator() .. ,
        }
        """
        self.__augList.update({obj.name:obj})
        obj.index = self.__current_count
        self.__current_count += 1
    
    def add_augObj_List(self, 
        augObj: List[AugOperator]
        )->None:
        """
        @desc
        >>> adds the Augmentation Operator Objects to a list.
        """
        self.__AugObjList = augObj
    
    def load_params(self,
        paramDict: dict)->None:
        """
        @desc
        >>> loads the parameter values for any particular epoch
        """
        for name, param in paramDict.items():
            self.operator(name).load_param(param)
    
    ### Main ###

    def apply_random(self, 
        data: List[PIL.Image.Image], 
        current_epoch:int=1, 
        update:bool = True
        )->Union[List[PIL.Image.Image], List[float]]:
        """
        @desc
        >>> apply randomly chosen augmentation operator over the image/batch of images

        @example
        >>> for epoch in range(epochs+1):
        >>>     for data,_ in dataloader:
        >>>         x_aug, x = Augs.apply_random(data, epoch), data
        """
        self.__update = update
        return self.__apply_random(data, current_epoch, update)

    def choose_random(self, 
        current_epoch:int=1
        )->None:
        """
        @desc
        >>> chooses a random Augmentation Operator from Augmentation Operator Pool
        which have highest probabilities or from the list generated by
        self._maxProb()

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.choose_random()
        >>> 
        >>> OUTPUT
        'blur'
        """
        if len(self.__ran_gen_list)>0:
            self.__ran_gen_list.clear()
        eta = ((current_epoch-1)*self.util.l)//self.util.te + 1
        for _ in range(eta):
            max_prob_names = self.__max_prob()
            name = choice(max_prob_names)
            self.operator(name).update_probability()
            self.__ran_gen_list.append(name)
    
    def compose(self, 
        data: List[PIL.Image.Image],
        current_epoch: int=1
        )->List[PIL.Image.Image]:

        params = self.get_parameters_value()
        for name, value in params.items():
            data = list(map(partial(self.operator(name).func, **value), data))
        return data
    
    def init(self, 
        dataset_size: int, 
        total_epochs: int, 
        batch_size: int, 
        lamda: int
        )->None:
        """
        @desc
        >>> add all the objects to _augList

        @example
        >>> Augs.show()
        {}
        >>> Augs.init(...)
        >>> Augs.show()
        { key:value ...}
        """
        self.__current_count = 0
        self.__reset_from_start()
        self.util.dataset_size(dataset_size).batch_size(batch_size).total_epochs(total_epochs).lamda(lamda)
        self.__add_objects(self.__AugObjList)
        self.util.omega(self.length())
        var = "DATASET_SIZE : {}\n, TOTAL_EPOCHS: {}\n, BATCH_SIZE : {}\n, LAMDA : {}\n, OMEGA : {}\n"
        print ("Augs Initiated with\n")
        return var.format(self.util.ds, self.util.te, self.util.bs, self.util.l, self.util.o)
    
    def selected_array(self)->List[float]:
        l = [0 for _ in range(self.util.o)]
        for name in self.__ran_gen_list:
            l[self.operator(name).index] = 1
        return l

    ### Read ###

    def frequency(self)->dict:
        """
        @desc
        gives a dictionary of all the frequency of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init()
        >>> Augs.frequency()
        >>> 
        >>> OUTPUT
        {
            'AugOprName' : <int>frequency,
            ...,
        }
        """
        new_dict = {}
        for key, value in self.__augList.items():
            new_dict.update({key: 1//value.probability})
        return new_dict
    
    def get_parameters_value(self, 
        filter: str=""
        )->dict:
        params = {}
        # print ("length: ", len(self.__ran_gen_list))
        # print ("selected list: ", self.__ran_gen_list)
        for name, augopr in self.__augList.items():
            if filter != "all" and name in self.__ran_gen_list:
                params.update({name:augopr.get_parameters(self.__update)})
            elif filter=="all":
                params.update({name:augopr.get_parameters(self.__update)})               
        return params

    def length(self)->int:
        return len(self.__augList)

    def probability(self)->dict:
        """
        @desc
        gives a dictionary of all the probabilities of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.probability()
        >>> 
        >>> OUTPUT
        {
            "AugOprName" : <float>probability,
            ...,
        }
        """
        new_dict = {}
        for key, value in self.__augList.items():
            new_dict.update({key: value.probability})
        return new_dict
    
    def show(self)->Union[dict,str]:
        """
        @desc
            return the _augList dictionary
        """
        return self.__augList

    def size(self)->str:
        """
        @desc
            returns the size of whole _augList dictionary in bytes, and string
            format.

        @example
            >>> INPUT 
            >>> Augs.size()
            >>> 
            >>> OUTPUT
            345 bytes
        """
        return self._string_size()

    def summary(self)->str:
        """
        @desc 
            gives the summary of Augmentation Pool
        """
        return self.__init_summary(self.util) + "\n" + self.show()
    
    ### Access ###

    def operator(self, 
        string:str
        )->AugOperator:
        """
        @desc
        functional form of indexing a list

        @example
        >>> INPUT
        >>> from ProAugs.augs import Augs
        >>> Augs.init()
        >>> Blur = Augs.operator('blur')
        >>> Blur.probability()
        >>> 
        >>> OUTPUT
        1.0
        """
        return self.__augList[string]

    ### Reset ###

    def reset(self, 
        current_epoch: int=1
        )->None:
        """
        
        """
        self.__reset_probability(current_epoch)
    
    ### Update ###

    def update_parameters(self, 
        current_epoch:int=1
        )->None:

        for aug_name in self.__ran_gen_list:
            self.operator(aug_name).update_parameters(self.util, current_epoch)
    
    def update_probability(self)->None:
        """
        @desc
            updates the probability of the randomly choosen Augmentation Operator.
            It works in conjunction with chooseRandom(). attribute _choice_name is
            assigned the chooseRandom() value, which is now publicily accessible in
            the dataclass.

        @example
        >>> INPUT
        >>> Augs.choose_random()
        >>> Augs.update_probability()
        """
        for aug in self.__ran_gen_list:
            self.__augList[aug].update_probability()
    
    ### Helper methods ###

    def __add_objects(self, 
        objs:List[AugOperator]
        )->dict:
        """
        @desc
        >>> adds the list of Augmentation Operator objects to _augList dictionary.
        If objs doesn't exist then objs would be added to _augList.
        """
        for obj in objs:
            self.__augList.update({obj.name:obj})
            obj.index = self.__current_count
            self.__current_count += 1
        return self.__augList
    
    def __apply_random(self, 
        data: List[PIL.Image.Image], 
        current_epoch: int=1, 
        update: bool=True
        )->Union[List[PIL.Image.Image], List[float]]:

        self.choose_random(current_epoch)
        if update:
            self.update_parameters(current_epoch)
        self.reset(current_epoch)
        return self.compose(data, current_epoch)
    
    def __reset_probability(self, 
        current_epoch: int=1
        )->None:
        if self.util.isChange(current_epoch):
            for _, value in self.__augList.items():
                value.probability = 1.0

    def __string_size(self)->str:
        """
        @desc
        >>> get the size of whole _augList dictionary in bytes
        """
        size = str(getsizeof(self._augList)) + " bytes"
        return size

    def __max_prob(self)->List[str]:
        """
        @desc
        >>> find the list of names of those Augmentation Operator Objects which have
        highest probability
        """
        max_value = max([value.probability for _, value in self.__augList.items()])
        max_aug_names = [key for key,value in self.__augList.items() if value.probability==max_value]
        return max_aug_names
    
    def __reset_from_start(self)->None:
        """
        @desc
        >>> to be used with Augs.init() to reset already executed values
        """
        ## Change the probabilities to default
        for _, value in self.__augList.items():
            value.probability = 1.0
        ## Change the AbstractRange updated values 
        self.__reset_params_to_default()

    def __reset_params_to_default(self)->None:
        """
        @desc
        >>> reset the params value to default
        """
        for _, value in self.__augList.items():
            value.reset_parameters()