# Import required modules
from dataclasses import dataclass, field
from numpy.random import choice
from typing import List, Union
from sys import getsizeof

# Custom modules
from .augOperator import AugOperator
from .color import Color
from ProAug import utils

@dataclass
class AugSeq:
    """
    @attr
        _augList: private data member. Dictionary to store all the AugOperators
        _choice_name: private data member. Holds the name of randomly choosen
                    Augmentation Operator
        _AugObjList: this list initially holds all the Augmentation Operators
                    in a list
    """

    def __post_init__(self):
        """
        @desc
        Initiates after init method automatically
        """
        self._AugObjList:List = []
        self._augList:dict = {}
        self._ran_gen_list:list = []
        self._choiceName:str=field(default='blur')
        self._meta_dict:dict = {}
    
    def __repr__(self):
        return self.__class__.__name__
    
    def add(self, obj:AugOperator)->None:
        """
        @desc
        add the Augmentation Operator object to Augmentation Pool

        @example
        >>> INPUT
        >>> trialOpr = AugOperator(...)
        >>> Augs.add(trialOpr)
        >>> Augs.show()
        >>> 
        >>> OUTPUT
        {
        ... ,
        'trial': Augmentation Operator() .. ,
        }
        """
        self._augList.update({obj.name:obj})
        return self._augList
    
    def add_objects(self, objs:List[AugOperator])->dict:
        """
        @desc
        adds the list of Augmentation Operator objects to _augList dictionary.
        If objs doesn't exist then objs would be added to _augList.
        """
        for obj in objs:
            self._augList.update({obj.name:obj})
        return self._augList
    
    def add_augObj_List(self, augObj:List)->None:
        """
        @desc
        adds the Augmentation Operator Objects to a list.
        """
        self._AugObjList = augObj
    
    def apply_random(self, current_epoch:int=1)->None:
        """
        @desc
        apply randomly chosen augmentation operator over the image/batch of images
        """
        return self._apply_augs(current_epoch)

    def choose_random(self, current_epoch:int=1)->List[str]:
        """
        @desc
        chooses a random Augmentation Operator from Augmentation Operator Pool
        which have highest probabilities or from the list generated by
        self._maxProb()

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.chooseRandom()
        >>> 
        >>> OUTPUT
        'blur'
        """
        eta = ((current_epoch-1)*utils.lamda)//utils.total_epochs + 1
        for _ in range(eta):
            max_prob_names = self._max_prob()
            self._choice_name = choice(max_prob_names)
            self._ran_gen_list.append(self._choice_name)
        return self._ran_gen_list
    
    def frequency(self)->dict:
        """
        @desc
        gives a dictionary of all the frequency of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init()
        >>> Augs.frequency()
        >>> 
        >>> OUTPUT
        {
            'AugOprName' : <int>frequency,
            ...,
        }
        """
        new_dict = {}
        for key, value in self._augList.items():
            new_dict.update({key: 1//value.probability})
        return new_dict
    
    def init(self, total_epochs:int, batch_size:int, lamda:int, omega:int)->str:
        """
        @desc
        add all the objects to _augList

        @example
        >>> Augs.show()
        {}
        >>> Augs.init(...)
        >>> Augs.show()
        { key:value ...}
        """
        utils.total_epochs = total_epochs
        utils.batch_size = batch_size
        utils.lamda = lamda
        utils.omega = omega
        self.add_objects(self._AugObjList)
        var = """{green}Initiated with 
        total_epochs:{magenta}{te}{green},
        batch_size:{magenta}{bs}{green},
        lamda:{magenta}{la}{green},
        omega:{magenta}{om}{reset}"""
        return var.format(
                green=Color.GREEN, magenta=Color.MAGENTA,
                reset=Color.RESET, te=total_epochs,
                bs=batch_size, la=lamda, om=omega
            )



    def operator(self, string:str)->AugOperator:
        """
        @desc
        functional form of indexing a list

        @example
        >>> INPUT
        >>> from ProAugs.augs import Augs
        >>> Augs.init()
        >>> Blur = Augs.operator('blur')
        >>> Blur.probability()
        >>> 
        >>> OUTPUT
        1.0
        """
        return self._augList[string]
    
    def probability(self)->dict:
        """
        @desc
        gives a dictionary of all the probabilities of augmentation operator objects

        @example
        >>> INPUT
        >>> Augs.init(...)
        >>> Augs.probability()
        >>> 
        >>> OUTPUT
        {
            "AugOprName" : <float>probability,
            ...,
        }
        """
        new_dict = {}
        for key, value in self._augList.items():
            new_dict.update({key: value.probability})
        return new_dict

    def reset(self, this:str)->None:
        """
        @desc
        reset the values

        @example
        >>> INPUT
        >>> Augs.reset("probabilities")
        >>> Augs.probabilities()
        >>> 
        >>> OUTPUT
        <all probabilities would be reseted to 1.0>
        """
        if this == "probabilities":
            for _, values in self._augList.items():
                values.probability = 1.0

    def show(self)->Union[dict,str]:
        """
        @desc
        return the _augList dictionary
        """
        return self._augList
    
    def size(self)->str:
        """
        @desc
        returns the size of whole _augList dictionary in bytes, and string
        format.

        @example
        >>> INPUT 
        >>> Augs.size()
        >>> 
        >>> OUTPUT
        345 bytes
        """
        return self._string_size()
    
    def update_parameters(self, rand_gen_list:List[str], current_epoch:int=1)->None:

        for aug in rand_gen_list:
            self.operator(aug).update_params(current_epoch)
    
    def update_probability(self, current_epoch:int=1)->None:
        """
        @desc
        updates the probability of the randomly choosen Augmentation Operator.
        It works in conjunction with chooseRandom(). attribute _choice_name is
        assigned the chooseRandom() value, which is now publicily accessible in
        the dataclass.

        @example
        >>> INPUT
        >>> Augs.choose_random()
        >>> Augs.update_probability()
        """
        for aug in self._ran_gen_list:
            self._augList[aug].update_prob()
    
    def _apply_augs(self, current_epoch:int=1)->None:

        rand_gen_list = self.choose_random(current_epoch)
        self.update_parameters(self._ran_gen_list, current_epoch)
        self._compose()
    
    def _compose(self):
        pass
    
    def _string_size(self)->str:
        """
        @desc
        get the size of whole _augList dictionary in bytes
        """
        size = str(getsizeof(self._augList)) + " bytes"
        return size

    def _max_prob(self)->List[str]:
        """
        @desc
        find the list of names of those Augmentation Operator Objects which have
        highest probability
        """
        max_value = max([value.probability for key, value in self._augList.items()])
        max_aug_names = [key for key,value in self._augList.items() if value.probability==max_value]
        return max_aug_names